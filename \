#include "PEntity.h"
#include "Entity.h"
#include "Utils.h"
#include <algorithm>
#include <cmath>
#include <iostream>
PEntity::PEntity(const std::string& texture, SDL_Rect rect,Window& wnd)
:Entity(texture, rect, wnd)
{



}


PEntity::PEntity(const Texture& texture, SDL_Rect rect)
:Entity(texture , rect)
{



}
    void PEntity::ChangeMass(float NewMass)
{
mass = NewMass;
}
void PEntity::SetRoughness(float roughness)
{
    friction_cof = roughness;
    if(friction_cof>1.0f)
        friction_cof = 1.0f;
    if(friction_cof<0.0f)
        friction_cof = 0.0f;


}


void PEntity::Gravitate(Vec2 point, float strength)
{
    SDL_Point center = Utils::GetCenter(hitbox);
    Vec2 diraction= (point - (Vec2){(float)center.x,(float)center.y})/GetDistance(point);
    velocity +={strength*diraction.x,strength*diraction.y};
}



  void PEntity::PhysicsCollision(const SDL_Rect& other)
{

    int interX = ((hitbox.x+hitbox.w)-(other.x +other.w)) + (hitbox.x - other.x);
    
    bool  interX_left=  interX < 0;

    int interY =  ((hitbox.y+hitbox.h)-(other.y +other.h)) + (hitbox.y - other.y);

    bool  interY_up=  interY < 0;
   
    if (( interY + (hitbox.h+other.h)) == 0 && interX < (hitbox.w+other.w) && interX > 0 -(hitbox.w+other.w))
        standing = true;
 

   if(interX < (hitbox.w+other.w) && interX > 0 -(hitbox.w+other.w) &&
        interY < (hitbox.h+other.h) && interY > 0 -(hitbox.h+other.h))
    {
        if((hitbox.w+other.w)-abs((int)interX )>(hitbox.h+other.h)-abs( interY ))
            {
                if(interY_up)
                    {
                        position.y = other.y-hitbox.h;
                        standing = true;
                    }
                else
                {
                    position.y = other.y+other.h;
                }


             hitbox.y =position.y;
             texture.rect.y = position.y;
             velocity.y = 0;          //normal force V
                float fricForce = velocity.x>0 ?friction_cof*(mass*abs(acceleration.y))*-1 : friction_cof*(mass*abs(acceleration.y));
            ApplyForce({fricForce,0});
            }
        else
        {

            if(interX_left)
                {
                    position.x = other.x-hitbox.w;
                }
            else
            {
                position.x = other.x+other.w;



            }

        hitbox.x = position.x;
        texture.rect.x = position.x;
        velocity.x = 0;
        velocity.y -= friction_cof*velocity.y;
        }
    }
}
  void PEntity::PhysicsCollision(PEntity& otherentity)
{
    SDL_Rect& other = otherentity.hitbox;

    int interX = ((hitbox.x+hitbox.w)-(other.x +other.w)) + (hitbox.x - other.x);
    
    bool  interX_left=  interX < 0;

    int interY =  ((hitbox.y+hitbox.h)-(other.y +other.h)) + (hitbox.y - other.y);

    bool  interY_up=  interY < 0;
   
    if (( interY + (hitbox.h+other.h)) == 0 && interX < (hitbox.w+other.w) && interX > 0 -(hitbox.w+other.w))
    {
        standing = true;
    }
        bool printinfo = false;

   if(interX < (hitbox.w+other.w) && interX > 0 -(hitbox.w+other.w) &&
        interY < (hitbox.h+other.h) && interY > 0 -(hitbox.h+other.h))
    {
        if((hitbox.w+other.w)-abs((int)interX )>(hitbox.h+other.h)-abs( interY ))
            {
                float system_force = ((velocity.y - otherentity.velocity.y) *std::min(otherentity.mass , mass));
                float saveypos = position.y;
                if(interY_up)
                    {
                       position.y = other.y-hitbox.h;
                        otherentity.position.y = position.y +hitbox.h;
                        standing = true;
                        if(system_force<0) 
                            system_force = 0;
                    }
                else
                {
                    position.y = other.y+other.h;
                    otherentity.position.y = position.y - other.h;
                    if(system_force>0) 
                        system_force = 0;
                    otherentity.standing = true;
                }
                hitbox.y =position.y;
                other.y = otherentity.position.y;
                texture.rect.y = hitbox.y;
                otherentity.texture.rect.y = other.y;
                ApplyForce({0,system_force *-1});
                otherentity.ApplyForce({0,system_force});
            }
        else
        {

            std::cout<<" "<<other.x<<std::endl;
            float system_force = ((velocity.x - otherentity.velocity.x) *std::min(otherentity.mass , mass));
            float savexpos = position.x;
            if(interX_left)
                {
                    position.x = other.x-hitbox.w;
                    otherentity.position.x = position.x +hitbox.w;

                    if(system_force<0) system_force = 0;
                }


            else
            {
                position.x = other.x+other.w;
                otherentity.position.x = position.x -other.w;
                if(system_force>0) system_force = 0;
            }
            hitbox.x = position.x;
            other.x = otherentity.position.x;
            texture.rect.x = hitbox.x;
            otherentity.texture.rect.x = other.x;
            ApplyForce({system_force *-1,0});
            otherentity.ApplyForce({system_force,0});
        }
    }
}

void PEntity::Limit (const SDL_Rect& border)
{
    if(position.x+hitbox.w>border.x+border.w)
    {
        position.x = border.x + border.w - hitbox.w;
        hitbox.x = position.x;
        velocity.x=0;
    }

    if(position.x<border.x)
    {
        position.x = border.x;
        hitbox.x = position.x;
        velocity.x=0;
    }
    if(position.y+hitbox.h>border.y+border.h)
    {
        position.y = border.y + border.h - hitbox.h;
        hitbox.y = position.y;
        velocity.y=0;
    }

    if(position.y<border.y)
    {
        position.y = border.y;
        hitbox.y = position.y;
        velocity.y=0;
    }
}

void PEntity::LimitSpeed(float limit)
{
    if((float)velocity>limit)
    {
        velocity /= (float)velocity/limit; 
    }
}

